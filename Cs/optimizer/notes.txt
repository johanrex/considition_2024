
* skriv ihop reglerna och fråga claude om han kan rekommendera algoritmer. 
* infer personality traits using binary search for the different personalities, in isolation. 
* hur väga risk vs profitability? Hur kvantifiera risk?
* personality - "during the final night, players must discover these values to maximize their total points."
* undersök en personlighet i taget och se hur det påverkar score.
* undersök vilka features som korrelerar med score. 
* genetisk strategi
* binary search - interestrate
* generate a ton of personalities and see how close I can get to the real values.
* calculate profitability for all persons and choose according to that. 
* formulera en funktion för profitability med interestrate och months to pay back och lånebelopp. Fundera hur man hittar ett maximum på denna funktion.
* rycka ur dllerna och anropa dom direkt utanför docker?


Tävlingsdag:
personalities.json ligger i Config mappen i dockerfilen. Kolla om sywor publicerar någon mer container: https://hub.docker.com/u/sywor

-------------

Scoring:

public bool CanPayLoan() => this.Capital >= this.Loan.GetTotalMonthlyPayment();

internal Decimal GetTotalMonthlyPayment()
{
    Decimal num1 = this.GetMonthlyInterestRate();
    if (num1 == 0M)
        num1 = 0.0001M;
    double x = (double)(1M + num1);
    Decimal num2 = num1 * (Decimal)Math.Pow(x, (double)this.MonthsToPayBack);
    Decimal num3 = (Decimal)Math.Pow(x, (double)this.MonthsToPayBack) - 1M;
    if (num3 == 0M)
        num3 = 0.0001M;
    return this.Amount * (num2 / num3);
}

private Decimal GetMonthlyInterestRate() => this.YearlyInterestRate / 12M;

public void PayBills(
    int iteration,
    Dictionary<Personality, PersonalitySpecification> personalityDict)
{
    bool flag = iteration % 3 == 0;
    this.Capital -= this.MonthlyExpenses * personalityDict[this.Personality].LivingStandardMultiplier - (Decimal)(this.HasStudentLoans & flag ? 2000 : 0) - (Decimal)(this.NumberOfKids * 2000) - this.Mortgage * 0.01M;
}

public Decimal PayLoan()
{
    this.Capital -= this.Loan.GetTotalMonthlyPayment();
    this.Loan.LowerRemainingBalance(this.Loan.GetPrincipalPayment());
    ++this.SuccessfulPaymentStreak;
    Decimal interestPayment = this.Loan.GetInterestPayment();
    this.Profit += interestPayment;
    return interestPayment;
}


public void CollectPayments(
    CustomerActionIteration iteration,
    int iterationIndex,
    List<Customer> customers,
    Map map)
{
    foreach (Customer customer in customers)
    {
        CustomerAction customerAction = iteration.CustomerActions[customer.Name];
        customer.Payday();
        // ISSUE: reference to a compiler-generated field
        customer.PayBills(iterationIndex, this.\u003CconfigService\u003EP.Personalities);
        if (customer.CanPayLoan())
            map.Budget += customer.PayLoan();
        else
            customer.IncrementMark();
        if (customerAction.Type == CustomerActionType.Award)
            map.Budget -= this.Award(customer, customerAction.Award);
    }
}


public bool Propose(
    Decimal yearlyInterestRate,
    int monthsToPayBack,
    Dictionary<Personality, PersonalitySpecification> personalityDict)
{
    Decimal? acceptedMinInterest = personalityDict[this.Personality].AcceptedMinInterest;
    Decimal? acceptedMaxInterest = personalityDict[this.Personality].AcceptedMaxInterest;
    Decimal num1 = yearlyInterestRate;
    Decimal? nullable1 = acceptedMinInterest;
    Decimal valueOrDefault1 = nullable1.GetValueOrDefault();
    if (!(num1 < valueOrDefault1 & nullable1.HasValue))
    {
        Decimal num2 = yearlyInterestRate;
        Decimal? nullable2 = acceptedMaxInterest;
        Decimal valueOrDefault2 = nullable2.GetValueOrDefault();
        if (!(num2 > valueOrDefault2 & nullable2.HasValue))
        {
            this.Loan.YearlyInterestRate = yearlyInterestRate;
            this.Loan.MonthsToPayBack = monthsToPayBack;
            return true;
        }
    }
    return false;
}


